#ifndef TEABAG_GAME_HPP
#define TEABAG_GAME_HPP

#include "defines.hpp"
#include "eventmanager.hpp"
#include "optionsparser.hpp"
#include "entity.hpp"
#include "entitymanager.hpp"
#include "map.hpp"

#include <iostream>

#include <SFML/Graphics.hpp>

TEABAG_NS

/**
 * The base class for a game.
 * This class is the starting point for anything created with the teabag
 * engine. It contains functions to manage initialisation, events, entities,
 * and the game map.
 */
class Game {
public:
	/**
	 * Constructs an empty Game object.
	 * This does not acually load anything. init() must be called to initialise
	 * the class properly.
	 */
	Game();

	/**
	 * Initialises the game.
	 * This reads the main game definition file, and initialises the window
	 * and optionally loads the first map.
	 *
	 * @param loadMapNow If true, loads the first map after initialising the
	 * window.
	 * @return Negative on failure, 0 on success.
	 */
	int init(bool loadMapNow = false);

	/**
	 * Loads the given map.
	 *
	 * @param mapname The map to load.
	 * @return Negative on failure, 0 on success.
	 */
	int loadMap(std::string mapname);

	/**
	 * Runs the game.
	 * Starts the main loop, calling tick callbacks every loop, event callbacks
	 * when the relevant events happen, and collision callbacks when the 
	 * relevant objects collide.
	 *
	 * @return Negative on error, 0 on clean exit.
	 */
	int run();

	/**
	 * Scrolls the map.
	 * 
	 * @param xd The distance to scroll the map horizontally.
	 * @param yd The distance to scroll the map vertically.
	 */
	void scrollMap(int xd, int yd);

	/**
	 * Gets an entity.
	 *
	 * @param name The name of the entity, as defined in the map's .tea file.
	 * @return A pointer to the entity.
	 */
	Entity getEntity(std::string name);

	/**
	 * Ends the game.
	 */
	void exit();

	// Event Functions
	/**
	 * @defgroup evtfuncs Event Connecting Functions
	 * These functions are all used to connect callback functions to events
	 * generated by SFML. The onEventName functions all take a function to add
	 * as a callback, and return 0 on success or negative on failure.
	 * @{
	 */
	int onClose(std::function<void(sf::Event)> callback);
	int onResize(std::function<void(sf::Event)> callback);
	int onFocusLoss(std::function<void(sf::Event)> callback);
	int onFocusGain(std::function<void(sf::Event)> callback);
	int onTextEntry(std::function<void(sf::Event)> callback);
	int onKeyPress(std::function<void(sf::Event)> callback);
	int onKeyRelease(std::function<void(sf::Event)> callback);
	int onMouseWheelMove(std::function<void(sf::Event)> callback);
	int onMouseButtonPress(std::function<void(sf::Event)> callback);
	int onMouseButtonRelease(std::function<void(sf::Event)> callback);
	int onMouseMove(std::function<void(sf::Event)> callback);
	int onMouseEntry(std::function<void(sf::Event)> callback);
	int onMouseLeave(std::function<void(sf::Event)> callback);
	int onJoystickButtonPress(std::function<void(sf::Event)> callback);
	int onJoystickButtonRelease(std::function<void(sf::Event)> callback);
	int onJoystickMove(std::function<void(sf::Event)> callback);
	int onJoystickConnection(std::function<void(sf::Event)> callback);
	int onJoystickDisconnection(std::function<void(sf::Event)> callback);

	/**
	 * Adds an event callback.
	 * Adds a function to be called whenever an event of the specified type
	 * is fired.
	 *
	 * @param eventType The event type the function is to be registered with.
	 * @param callback The function to be called.
	 * @return Negative on failure, 0 on success.
	 */
	int addEventCallback(sf::Event::EventType eventType, std::function<void(sf::Event)> callback);

	/**
	 * Adds a key callback.
	 * Any function added here gets called every tick the key is held down.
	 *
	 * @param keyCode The key to register the function with.
	 * @param callback The function to be called.
	 * @return Negative on failure, 0 on success.
	 */
	int onKey(sf::Keyboard::Key keyCode, std::function<void()> callback);

	/**
	 * Adds a collision callback.
	 * Any function added here gets called every tick the provided entity is
	 * colliding with either another entity or a tile.
	 *
	 * @param entityName The name of the entity.
	 * @param callback The function to be called.
	 * @return Negative on failure, 0 on success.
	 */
	int onCollision(std::string entityName, std::function<void(sf::FloatRect, sf::FloatRect, sf::FloatRect)> callback);

	/**
	 * @}
	 */

private:
	sf::RenderWindow gameWind;

	internal::TileManager tileManager;
	internal::EntityManager entityManager;
	internal::GameMap gameMap;
	internal::EventManager eventManager;

	sf::Sprite mapSprite;	

}; // class Game;

TEABAG_NS_END

#endif // TEABAG_GAME_HPP
